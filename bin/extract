#!/usr/bin/perl

use strict;
use FindBin;
use File::Basename;
use Getopt::Std;
use Config::Tiny;
use File::Spec;
use File::Path;
use File::Rsync;

sub usage {
  my $me = basename($FindBin::RealScript);
  die "usage: $me [-v] [-n] [-c <config>] [-t <timeout_sec>] [<host1>] [<host2> ...]\n";
}

my %opts = ();
getopts('h?c:nt:v', \%opts);
my $conf_file = $opts{c} || '/etc/extract/extract.conf';
my $help = $opts{h} || $opts{'?'};
my $noop = $opts{n};
my $timeout = $opts{t} || 60;
my $verbose = $opts{v};

usage if $help;

# Read config file
my $config = Config::Tiny->read($conf_file);
$config ||= Config::Tiny->read(File::Spec->catfile( $FindBin::RealBin, File::Spec->updir, 'etc', 'extract.conf' ));
die "Cannot find extract.conf config file '$conf_file'\n" unless $config;

# Get list of hosts to extract from
my @hosts = @ARGV;
if (! @hosts) {
  my $hosts = $config->{_}->{hosts} || qx($config->{_}->{host_cmd});
  @hosts = split(/\s+/, $hosts) if $hosts;
}

usage if ! @hosts;

# Check we have other required settings
my $root = $config->{_}->{root} or die "Cannot find required 'root' property in extract.conf\n";
my $file = $config->{_}->{files} or die "Cannot find required 'files' property in extract.conf\n";
-d $root or die "Extract root '$root' does not exist or is not a directory\n";
-w $root or die "Extract root '$root' is not writeable\n";
my @pre_extract_host = ();
my @post_extract_host = ();
my @post_extract_host = ();
if ($config->{_}->{pre_extract_host}) {
  @pre_extract_host = split /\s*,\s*/, $config->{_}->{pre_extract_host};
}
if ($config->{_}->{post_extract_host}) {
  @post_extract_host = split /\s*,\s*/, $config->{_}->{post_extract_host};
}

chdir $root or die "Cannot chdir to extract root '$root': $!\n";

# Iterate over hosts, doing extracts
my %extra = ( $verbose ? (verbose => 1) : (quiet => 1) );
$extra{'dry-run'} = 1 if $noop;
my $rsync = File::Rsync->new( { archive => 1, 'copy-links' => 1, 'delete' => 1, 
  'files-from' => ":$file", %extra })
    or die "rsync construction failed: $!\n";
for my $host (@hosts) {
  # Support user@host format hosts
  my $user = '';
  ($user, $host) = split(/\@/, $host, 2) if $host =~ m'@';
  print "+ connecting as $user\@$host\n" if $user && $verbose;
  
  # Create host dir, if required
  die "Cannot mkdir $host: $!\n" unless -d $host or mkdir $host;
  print "+ extracting from $host ...\n" if $verbose;

  # Pre-extract processing
  for my $script (@pre_extract_host) {
    unless (-x $script) {
      print "Invalid pre_extract_host script $script - skipping\n";
      next;
    }
    print "+ pre_extract_host $script ...\n" if $verbose;
    my $out = qx($script $root $host $file);
    print $out if $out && $verbose;
  }

  # Timeout protection
  eval {
    local $SIG{ALRM} = sub { die "Timeout!" };
    alarm $timeout;
    my $src = $user ? "$user\@$host:/" : "$host:/";
    if ($verbose) {
      my ($cmd) = $rsync->getcmd({ src => $src, dest => $host } );
      printf "+ %s\n", join(' ', @$cmd);
    }
    $rsync->exec({ src => $src, dest => $host });
  };
  alarm 0;
  if ($@) {
    if ($@ =~ qr/^Timeout!/) {
      print "\n** Timeout! **\n\n";
      next;
    }
    else {
      # Reraise exception
      die $@;
    }
  }

  # Process errors and output
  if (my $err = $rsync->err) {
    print "Errors from $host:\n  ";
    print join('  ', @$err);
    next;
  }
  if ($verbose) {
    print "+ cmd: " . $rsync->lastcmd . "\n";
    if (my $out = $rsync->out) {
      print join('', @$out);
    }
    print "\n";
  }

  # Post-extract processing
  for my $script (@post_extract_host) {
    unless (-x $script) {
      print "Invalid post_extract_host script $script - skipping\n";
      next;
    }
    print "+ post_extract_host $script ...\n" if $verbose;
    my $out = qx($script $root $host $file);
    print $out if $out && $verbose;
  }
}

print "\n+ done.\n" if $verbose;

__END__

=head1 NAME

extract - a utility to copy a set of files off one or more remote hosts
into a set of local host trees

=head1 SYNOPSIS

    extract [-c <config_file>] [<host1> [<host2> ...]]

=head1 DESCRIPTION

extract is a utility to copy a set of files off one or more remote hosts
into a set of local host trees. 

=head1 AUTHOR

Gavin Carr <gavin@openfusion.com.au>

=head1 LICENSE

Copyright 2007, Gavin Carr

This software is licensed under the GNU General Public Licence, Version 2.

=cut


